算法| 再也不怕被问时间复杂度了 （下）

> 在上篇文章[再也不怕被问时间复杂度了 （下）](https://blog.csdn.net/qq_41907991/article/details/97443681)，我们已经学习了为什么要进行时间复杂度分析，同时已经学习了如何进行时间复杂度的分析，这篇文章我们进一步学习时间复杂度的相关内容

[TOC]

##### 最好情况时间复杂度，最坏情况时间复杂度

我们看一个例子：

```java
// 这段代码是为了在数组中找到n第一次出现的下标
public int find(int[] array, int n) {
    int pos=-1;
    for (int i = 0; i < array.length; i++) {
        if(n==array[i]){
            pos=i;
        }
    }
    return pos;
}
```

从我们上一章学习的内容我们可以很简单的知道，上面代码的时间复杂度为O(n)，数组长度越长，耗时越长。不过很明显，上面的代码可以优化，优化后如下：

```java

```

我们只需要在找到指定元素后直接结束函数就行了。在这种情况下，我们之前学习的时间复杂度的分析方法已经不适用了。因为我们要查找的元素可能出现在数组中的任意一个元素，甚至在数组中不存在。如果出现在数组中的第一个元素的话，那么时间复杂度就是O(1)，但如果在数组中不存在，这种情况下我们需要遍历整个数组，时间复杂度为O(n)，所以在不同清空下，这段代码的时间复杂度是不一样的。顾名思义，这段代码的最好情况时间复杂度就是O(1),最坏情况时间复杂度就是O(n),那么平均复杂度又该如何计算呢？不要急，请往下看~

##### 平均情况时间复杂度

如果我们以最好，最坏时间复杂来评判上面的算法的话，很明显是不合理的，因为这两种情况都是在极端情况下才能出现的，这个时候我们需要引入新的评判指标，平均时间复杂度。那么平均时间复杂度又该如何计算呢？要查找的变量有两种情况

1. 在数组中。在数组中的话，可能出现在数组的每一个位置上，所以共有array.length中情况
2. 不在数组中

假设在数组中跟不在数组中的概率均为二分之一，数组长度为n，那么查找的元素出现在数组中任意位置的概率为：1/2n，那么平均时间复杂度可以这样计算：
$$
1*1/2n+2*1/2n+....+n*1/2n+n*1/2=(3n+1)/4
$$
其中1，2......n，代表每种情况下需要遍历的元素的个数，这种情况下平均时间复杂度还是O(n)

了解后我们会发现，平均复杂度的分析相对来说是很复杂的，还要引入概率论的知识。但是在大多数情况下我们不需要区分最好，最坏，平均情况时间复杂度三种情况，很多情况下，我们使用一个复杂度就可以满足需求了。只有同一块代码在不同情况下，时间复杂度有量级的差距，我们才使用这三种复杂度来区分

##### 均摊时间复杂度

我们还是以代码来进行说明：

```java

```

在上面的例子中，大多数情况下我们的时间复杂度都是O(1)，但是当数组中元素满了后，因为要遍历整个数组，这种情况下时间复杂度为O(n)，而且我们可以发现，每n-1次O(1)后，必然伴随着一次O(n)。大家可以思考下，这种情况我们之前说的最好，最坏，平均复杂度分别是多说呢？不难计算分别为，O(1),O(n),O(1)。但是由于上面的算法时间复杂度出现是有规律的，这个时候我们可以引入一个新的概念，即均摊时间复杂度。这样可以帮助我们更好的评判一个算法的优劣。那么均摊时间复杂度该如何计算呢？

我们可以这样思考，每n-1次O(1)的插入之后都会跟着一次O(n)的的插入，那么将耗时多的一次操作均摊到之前的n-1次上，当n趋近无穷大时，该算法的复杂度也就是O(1)了，这就是我们要说的均摊时间复杂度。

##### 总结：

到这里为止，我们就介绍完了各种时间复杂度的概念了。我们需要知道的是，之所以要建立这么多概念是为了更好的对一个算法进行分析，让我们能更全面的分析一个算法的优劣，因为在某些情况下，我们单独依赖于最好，最好，或者平均等时间复杂度进行分析都是不够全面的。

喜欢的朋友点个赞，加个关注吧，万分感谢~