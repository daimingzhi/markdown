Spring Cloud 学习 之 Spring Cloud Eureka（架构）

Spring Boot版本：2.1.4.RELEASE

Spring Cloud版本：Greenwich.SR1

[TOC]



#### Eureka服务治理基础架构的三个核心要素：

- **服务注册中心：**Eureka提供的服务端，**提供服务注册与发现功能**，也就是我们之前实现的eureka-server
- **服务提供者：**提供服务的应用，可以是Spring Boot应用，也可以是其他技术平台且遵循Eureka通信机制的应用。它将自己提供的服务注册到Eureka，以供其他应用调用

- **服务消费者：**消费者应用从服务注册中心获取服务列表，从而使消费者可以知道去何处调用其所需要的服务。

#### 服务治理机制：



![eureka机制](H:\markdown\images\eureka机制.png)

我们以上面这张图来分析eureka的运行机制：

1. ”服务注册中心1“和“服务注册中心2”互相组成了高可用集群
2. “服务提供者”启动了两个实例，一个注册到“服务注册中心1”，另外一个注册到“服务注册中心2”上
3. 还有俩个“服务消费者”，他们也都分别只指向了一个注册中心

##### 服务提供者：

1. 服务注册：

   ​	`服务提供者`在启动的时候会通过**发送REST请求的方式将自己注册到Eureka Server上**，同时带上了自身服务的一些**元数据**信息。Eureka Server接收到这个REST请求后，将元信息存储在一个双层Map结构中，其中第一层的key是服务名，第二层的key是具体服务的实例名，在服务注册时，需要确认一下`eureka.client.register-with-eureka=true`，参数是否正确，该值默认为true。若设置为false将不会启动注册操作。

2. 服务同步

   ​	如架构图中所示，这里的两个服务提供者分别注册到了两个不同的服务注册中心上，也就是说，他们的信息分别被两个服务注册中心所维护。此时，由于服务注册中心之间因为互相注册为服务，当服务提供者发送注册请求到一个服务注册中心上，它会将该请求转发给集群中相连的其他注册中心。从而实现注册中心之间的服务同步。通过服务同步，两个服务提供者的服务信息就可以通过这两台服务注册中心的任意一台获取到。

3. 服务续约

   ​	在注册完服务后，服务提供者会维护一个心跳用来持续告诉注册中心：”我还是活着“，以防止Eureka Server的”剔除任务“将该服务实例从服务列表中排除出去，我们称该操作为服务续约。

   ​	关于服务续约有两个重要的属性，我们可以关注并根据需要来调整：

   ​	`eureka.instance.lease-expiration-duration-in-seconds`: 定义服务的失效时间，默认90秒

   ​	`eureka.instance.lease-renewal-interval-in-seconds`：续约任务的调用间隔时间，默认30秒

##### 服务消费者：

1. 获取服务

   ​	在这里，在服务注册中心已经注册了一个服务，并且该服务有两个实例。当我们启动服务消费者的时候，它会发送一个**REST请求给服务注册中心，来获取上面注册的服务清单**。为了性能考虑，**Eureka Server会维护一份只读的服务清单来返回给客户端，同时该缓存的清单会每隔30秒刷新一次**。

   ​	获取服务是服务消费者的基础，所以必须确保`eureka.client.fetch-registry=true`,该值默认为true,若希望修改缓存清单的更新时间，可以通过`eureka.client.registry-fetch-interval-seconds`调整，默认为30s.

2. 服务调用

   ​	服务消费者在获取服务清单后，通过服务名可以获得具体提供服务的实例名和获取该实例的元数据信息。因为有这些服务实例的详细信息，所以**客户端可以根据自己的需要决定具体调用哪个实例，在Ribbon中会默认采用轮询的方式进行调用，从而实现客户端的负载均衡。**

   ​	对于访问实例的选择，Eureka中有Region和Zone的概念，一个Region中可以包含多个Zone，每个服务客户端需要被注册到一个Zone中，所以每个客户端对于一个Region和一个Zone。在进行服务调用的时候，优先访问同处一个Zone中的服务提供方，若访问不到，就访问其他的Zone。

3. 服务下线

   ​	在系统运行过程中必然会面临关闭或者重启服务的某个实例的情况，在服务关闭期间，我们自然不希望客户端会继续调用关闭了的实例。所以在客户端程序中，当服务实例进行正常的关闭操作时，他会触发一个服务下线的REST请求给Eureka Server,告诉服务注册中心：“我要下线了”。服务端在接受到请求

##### 服务注册中心：

1. 失效剔除

   ​	有些时候，我们的服务实例并不一定会正常下线，可能由于内存溢出，网络故障等原因使得服务不能正常工作，而服务注册中心并未收到“服务下线”的请求。为了从服务列表中将这些无法提供服务的实例剔除，Eureka Server在启动的时候会创建一个定时任务，默认每隔一段时间（默认60秒）将当前清单中超时（默认为90秒）没有续约的服务剔除出去。

2. 自我保护

   ​	当我们在本地调试基于Eureka的程序时，基本上都会碰到这样一个问题，在服务注册中心的信息面板中出现类似下面的红色警告信息：

   ```
   EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY'RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.
   ```

   ​	实际上，该警告就是触发了Eureka Server的自我保护机制。之前我们介绍过，服务注册到Eureka Server之后，会维护一个心跳连接，告诉Eureka Server自己是否还活着。Eureka Server在运行期间，会统计心跳失败比例在15分钟之内是否低于85%，如果出现低于的情况，Eureka Server会将当前的实例注册信息保护起来，让这些实例不会过期，尽可能保护这些注册信息。但是，在这段保护期间内实例若出现问题，那么客户端很容易拿到实际不存在的服务实例，会出现调用失败的情况，所以客户端必须要容错机制，比如可以使用请求重试，断路器等机制。

   ​	由于本地调试很容易触发注册中心的保护机制，这会使得注册中心维护的服务实例不那么准确。所以，我们在本地进行开发的时候，可以使用`eureka. server.enable-self-preservation=false`参数来关闭保护机制，以确保注册中心可以将不可用的实例正确剔除。 

​	